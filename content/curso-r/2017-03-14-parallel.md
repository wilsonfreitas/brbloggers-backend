+++
title = "Paralelização no R"
date = "2017-03-19 11:07:31"
categories = ["curso-r"]
+++

<div><p class="text-muted text-uppercase mb-small text-right"> Por <a href="http://curso-r.com/author/julio">Julio</a> 19/03/2017 </p><div id="post-content"> <p>Programadores eficientes n&#xE3;o precisam escrever algoritmos que rodam r&#xE1;pido. Recomendo fortemente a leitura do livro <a href="https://csgillespie.github.io/efficientR/">Efficient R</a>, que discute efici&#xEA;ncia com o R de forma exaustiva. Tamb&#xE9;m gosto muito da primeira parte <a href="https://www.youtube.com/watch?v=wki0BqlztCo">dessa palestra do Hadley</a>, onde ele defende que o cientista de dados deve usar seu tempo pensando no problema e n&#xE3;o na forma que vai escrever seu c&#xF3;digo.</p>
<p>Com isso em mente, vamos investigar o tema <em>paraleliza&#xE7;&#xE3;o</em>. Quando rodamos coisas em paralelo, mandamos os n&#xFA;cleos de processamento da m&#xE1;quina calcularem coisas diferentes ao mesmo tempo. A vantagem disso &#xE9; que o tempo de execu&#xE7;&#xE3;o dos algoritmos &#xE9; dividido pelo n&#xFA;mero de n&#xFA;cleos dispon&#xED;veis, sem exigir grandes mudan&#xE7;as no c&#xF3;digo utilizado.</p>
<p>Vamos mostrar como paralelizar um c&#xF3;digo usando a fun&#xE7;&#xE3;o <code>llply()</code> do pacote <code>plyr</code>. Essa fun&#xE7;&#xE3;o funciona de forma id&#xEA;ntica ao <code>lapply()</code>, ou seja, recebe uma lista ou vetor como input, aplica uma fun&#xE7;&#xE3;o em cada elemento, e retorna os resultados numa lista com o mesmo comprimento.</p>
<p>A fun&#xE7;&#xE3;o <code>dormir()</code> manda o R esperar <code>seg</code> segundos antes de concluir, retornando <code>seg</code>.</p>
<pre class="r"><code>dormir &lt;- function(seg = 1) { Sys.sleep(seg) return(seg)
}</code></pre>
<p>&#xC9; intuitivo afirmar que o tempo de execu&#xE7;&#xE3;o de <code>dormir()</code> &#xE9; compat&#xED;vel com <code>seg</code>.</p>
<pre class="r"><code>system.time({ dormir()
})
## user system elapsed ## 0.000 0.000 1.001</code></pre>
<p>Nosso interesse &#xE9; aplicar <code>dormir()</code> em cada elemento do vetor <code>c(1, 2)</code>. Esse algoritmo demora <code>1 + 2 = 3</code> segundos.</p>
<pre class="r"><code>segundos &lt;- c(1, 2)
system.time({ plyr::llply(segundos, dormir)
})
## user system elapsed ## 0.004 0.000 3.011</code></pre>
<p>Agora vamos executar o mesmo c&#xF3;digo usando paraleliza&#xE7;&#xE3;o. Antes, precisamos</p>
<ol>
<li>criar e registrar as c&#xF3;pias de R que rodam em paralelo; e</li>
<li>adicionar o par&#xE2;metro <code>.parallel = TRUE</code> no <code>llply()</code></li>
</ol>
<p>O primeiro passo &#xE9; resolvido com os pacotes <code>parallel</code> e <code>doParallel</code>. Veja como fica o c&#xF3;digo:</p>
<pre class="r"><code>cl &lt;- parallel::makePSOCKcluster(2) # cria as c&#xF3;pias do R que rodam em paralelo
doParallel::registerDoParallel(cl) # registra as c&#xF3;pias do R para serem usadas no plyr system.time({ plyr::llply(segundos, dormir, .parallel = TRUE)
})
## user system elapsed ## 0.164 0.004 2.338</code></pre>
<p>O tempo total de execu&#xE7;&#xE3;o foi de ~2.2 segundos, um pouco mais do que <code>dormir(2)</code>. Os dois d&#xE9;cimos de segundo adicionais s&#xE3;o necess&#xE1;rios para preparar o terreno da paraleliza&#xE7;&#xE3;o. Inclusive, se voc&#xEA; rodar o c&#xF3;digo em paralelo novamente, o tempo adicional cai para quase nada:</p>
<pre class="r"><code>system.time({ plyr::llply(segundos, dormir, .parallel = TRUE)
})
## user system elapsed ## 0.152 0.000 2.244</code></pre>
<p>Se quiser parar de rodar coisas em paralelo, basta rodar <code>stopCluster()</code>:</p>
<pre class="r"><code>parallel::stopCluster(cl) # p&#xE1;ra de rodar coisas em paralelo</code></pre>
<p>E &#xE9; isso, caros errantes. Rappy coding :)</p> </div></div>
