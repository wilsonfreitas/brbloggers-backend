+++
title = "Colando textos"
date = "2017-04-17 11:07:31"
categories = ["curso-r"]
+++

<div><p class="text-muted text-uppercase mb-small text-right"> Por <a href="http://curso-r.com/author/julio">Julio</a> 17/04/2017 </p><div id="post-content"> <p>Uma tarefa muito comum no <code>R</code> &#xE9; colar textos. As fun&#xE7;&#xF5;es mais importantes para isso s&#xE3;o <code>paste()</code> e <code>sprintf()</code>, que v&#xEA;m com o pacote <code>base</code>. Nesse artigo, vamos falar dessas duas fun&#xE7;&#xF5;es e de um novo pacote do <code>tidyverse</code>, o <code>glue</code>.</p>
<div id="paste" class="section level2"> <p>A fun&#xE7;&#xE3;o <code>paste()</code> recebe um conjunto indeterminado de objetos como argumento atrav&#xE9;s do <code>...</code> e vai colando os objetos passados elemento a elemento. Isso significa que se voc&#xEA; passar dois vetores de tamanho <code>n</code>, a fun&#xE7;&#xE3;o <code>paste()</code> retornar&#xE1; um vetor de tamanho <code>n</code> sendo cada posi&#xE7;&#xE3;o a colagem dos dois vetores nessa posi&#xE7;&#xE3;o. Por padr&#xE3;o, a colagem &#xE9; feita com um separador de espa&#xE7;o simples (<code>&quot; &quot;</code>). Exemplo:</p>
<pre class="r"><code>paste(c(1, 2, 3), c(4, 5, 6))
## [1] &quot;1 4&quot; &quot;2 5&quot; &quot;3 6&quot;</code></pre>
<p>&#xC9; poss&#xED;vel alterar o separador pelo argumento <code>sep =</code>. Um atalho &#xFA;til para o separador vazio (<code>&quot;&quot;</code>) &#xE9; a fun&#xE7;&#xE3;o <code>paste0</code>:</p>
<pre class="r"><code>paste0(c(1, 2, 3), c(4, 5, 6))
## [1] &quot;14&quot; &quot;25&quot; &quot;36&quot;</code></pre>
<p>Algumas vezes nosso interesse n&#xE3;o &#xE9; juntar vetores elemento a elemento, mas sim passar um vetor e colar todos seus elementos. Isso &#xE9; feito com o par&#xE2;metro <code>collapse =</code>:</p>
<pre class="r"><code>paste(c(1, 2, 3, 4, 5, 6), collapse = &apos;@&apos;)
## [1] &quot;1@2@3@4@5@6&quot;</code></pre>
<p>Se voc&#xEA; passar mais de um vetor e mandar colapsar os elementos, o <code>paste()</code> vai primeiro colar e depois colapsar:</p>
<pre class="r"><code>paste(c(1, 2, 3), c(4, 5, 6), collapse = &apos;@&apos;)
## [1] &quot;1 4@2 5@3 6&quot;</code></pre>
<div id="cuidado" class="section level3"> <p>Tenha muito cuidado ao passar vetores com <strong>comprimentos diferentes</strong> no <code>paste()</code>! Assim como muitas fun&#xE7;&#xF5;es do R, o <code>paste()</code> faz reciclagem, ou seja, ele copia os elementos do menor vetor at&#xE9; ele ficar com o comprimento do maior vetor<a href="http://curso-r.com/blog/2017/04/17/2017-04-08-glue/#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. O problema &#xE9; que o <code>paste()</code> faz isso silenciosamente e n&#xE3;o avisa se voc&#xEA; inserir um vetor com comprimento que n&#xE3;o &#xE9; m&#xFA;ltiplo dos demais. Veja que resultado bizarro:</p>
<pre class="r"><code>paste(5:9, 1:3, 4:5)
## [1] &quot;5 1 4&quot; &quot;6 2 5&quot; &quot;7 3 4&quot; &quot;8 1 5&quot; &quot;9 2 4&quot;</code></pre>
<p>Por essas e outras que dizemos que &#xE0;s vezes o R funciona bem demais&#x2026;</p>
</div>
</div>
<div id="sprintf" class="section level2"> <p>O <code>sprintf()</code> &#xE9; similar ao <code>printf</code> do <code>C</code>. Primeiro escrevemos um texto com <code>%s</code> no lugar das coisas que queremos substituir. Depois colocamos esses objetos nos outros argumentos da fun&#xE7;&#xE3;o, na ordem em que eles aparecem no texto.</p>
<pre class="r"><code>sprintf(&apos;Aba%ste&apos;, &apos;ca&apos;)
## [1] &quot;Abacate&quot;</code></pre>
<p>Quando o argumento &#xE9; um vetor, a fun&#xE7;&#xE3;o retorna um vetor com as substitui&#xE7;&#xF5;es ponto a ponto.</p>
<pre class="r"><code>sprintf(&apos;Aba%ste&apos;, c(&apos;ca&apos;, &apos;ixas&apos;))
## [1] &quot;Abacate&quot; &quot;Abaixaste&quot;</code></pre>
<p>Se o texto cont&#xE9;m mais de um <code>%s</code> e os objetos correspondentes s&#xE3;o vetores, o <code>sprintf()</code> tenta <em>reciclar</em> os vetores para ficarem do mesmo tamanho. Isso s&#xF3; funciona quando todos os objetos t&#xEA;m comprimentos que s&#xE3;o m&#xFA;ltiplos do comprimento do maior objeto.</p>
<p>Isso funciona:</p>
<pre class="r"><code>sprintf(&apos;Aba%s%s&apos;, c(&apos;ca&apos;), c(&apos;xi&apos;, &apos;te&apos;)) # ca foi reciclado
## [1] &quot;Abacaxi&quot; &quot;Abacate&quot;</code></pre>
<p>Isso n&#xE3;o funciona:</p>
<pre class="r"><code>sprintf(&apos;Aba%s%s&apos;, c(&apos;ca&apos;, &apos;ixaste&apos;), c(&apos;xi&apos;, &apos;te&apos;, &apos;.&apos;))
## Error in sprintf(&quot;Aba%s%s&quot;, c(&quot;ca&quot;, &quot;ixaste&quot;), c(&quot;xi&quot;, &quot;te&quot;, &quot;.&quot;)): arguments cannot be recycled to the same length</code></pre>
<p>Nem sempre queremos substituir peda&#xE7;os do nosso texto por outros textos. No lugar do <code>%s</code>, &#xE9; poss&#xED;vel colocar padr&#xF5;es para n&#xFA;meros, por exemplo. Eu uso bastante o <code>%d</code>, que recebe inteiros. Uma funcionalidade legal do <code>%d</code> &#xE9; a possibilidade de adicionar zeros &#xE0; esquerda quando um n&#xFA;mero n&#xE3;o atinge certa quantidade de d&#xED;gitos. Assim, quando ordenamos um vetor de textos que come&#xE7;a com n&#xFA;meros, a ordena&#xE7;&#xE3;o &#xE9; a mesma da vers&#xE3;o num&#xE9;rica do vetor.</p>
<p>Exemplo:</p>
<pre class="r"><code>nums &lt;- 1:11
sort(as.character(nums)) # ordenado pela string: 10 vem antes de 2
## [1] &quot;1&quot; &quot;10&quot; &quot;11&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot;
sort(sprintf(&apos;%02d&apos;, nums)) # ordenado pela string: 02 vem antes de 10
## [1] &quot;01&quot; &quot;02&quot; &quot;03&quot; &quot;04&quot; &quot;05&quot; &quot;06&quot; &quot;07&quot; &quot;08&quot; &quot;09&quot; &quot;10&quot; &quot;11&quot;</code></pre>
</div>
<div id="glue" class="section level2"> <p>O <a href="https://github.com/tidyverse/glue"><code>glue</code></a> &#xE9; um pacote recente. Sua primeira apari&#xE7;&#xE3;o no GitHub foi em 23/12/2016! Isso significa que &#xE9; prov&#xE1;vel que algumas coisas mudem, mas isso n&#xE3;o nos impede de aproveitar o que a ferramenta tem de bom.</p>
<p>A fun&#xE7;&#xE3;o <code>glue()</code> &#xE9; uma generaliza&#xE7;&#xE3;o do <code>sprintf()</code> que permite chamar objetos do R diretamente ao inv&#xE9;s de utilizar o <code>%s</code>. Os objetos podem estar no <em>global environment</em> ou descritos por meio de objetos nomeados nos argumentos do <code>glue()</code>. Basta inserir os objetos entre chaves <code>{}</code>:</p>
<pre class="r"><code>library(glue)
planeta &lt;- &apos;mundo&apos;
glue(&apos;Ol&#xE1; {planeta} pela {y}a vez&apos;, y = 1)
## Ol&#xE1; mundo pela 1a vez</code></pre>
<p>Temb&#xE9;m &#xE9; poss&#xED;vel adicionar express&#xF5;es dentro das chaves:</p>
<pre class="r"><code>p &lt;- 1.123123123
glue(&apos;{p * 100}% das pessoas adoram R.&apos;)
## 112.3123123% das pessoas adoram R.</code></pre>
<pre class="r"><code>glue(&apos;{scales::percent(p)} das pessoas adoram R.&apos;)
## 112% das pessoas adoram R.</code></pre>
<p>A fun&#xE7;&#xE3;o <code>collapse()</code> &#xE9; parecida com o <code>paste()</code> quando <code>collapse = &apos;&apos;</code>, mas s&#xF3; aceita um objeto como entrada:</p>
<pre class="r"><code>x &lt;- collapse(1:10)
x
## [1] &quot;12345678910&quot;
all.equal(x, paste(1:10, collapse = &apos;&apos;))
## [1] TRUE</code></pre>
<p>Se quiser colar os objetos elemento a elemento e depois colapsar, fa&#xE7;a isso explicitamente em duas opera&#xE7;&#xF5;es:</p>
<pre class="r"><code>glue(&apos;{letters}/{LETTERS}&apos;) %&gt;% collapse(&apos;, &apos;)
## [1] &quot;a/A, b/B, c/C, d/D, e/E, f/F, g/G, h/H, i/I, j/J, k/K, l/L, m/M, n/N, o/O, p/P, q/Q, r/R, s/S, t/T, u/U, v/V, w/W, x/X, y/Y, z/Z&quot;</code></pre>
<p>O <code>glue</code> tamb&#xE9;m tem uma fun&#xE7;&#xE3;o extra para trabalhar melhor com o <code>%&gt;%</code>, o <code>glue_data()</code>. O primeiro argumento dessa fun&#xE7;&#xE3;o &#xE9; uma lista ou <code>data.frame</code>, e seus nomes s&#xE3;o utilizados como vari&#xE1;veis para alimentar as chaves das strings. Use o <code>.</code> para fazer opera&#xE7;&#xF5;es com toda a base de dados:</p>
<pre class="r"><code>mtcars %&gt;% head() %&gt;% glue_data(&apos;O carro {row.names(.)} rende {mpg} milhas por gal&#xE3;o.&apos;)
## O carro Mazda RX4 rende 21 milhas por gal&#xE3;o.
## O carro Mazda RX4 Wag rende 21 milhas por gal&#xE3;o.
## O carro Datsun 710 rende 22.8 milhas por gal&#xE3;o.
## O carro Hornet 4 Drive rende 21.4 milhas por gal&#xE3;o.
## O carro Hornet Sportabout rende 18.7 milhas por gal&#xE3;o.
## O carro Valiant rende 18.1 milhas por gal&#xE3;o.</code></pre>
</div>
<div id="resumo" class="section level2"> <ul>
<li>Use <code>paste()</code> para colar ou colapsar elementos usando um separador fixado.</li>
<li>Use <code>sprintf()</code> quando quiser colocar objetos dentro de um texto complexo.</li>
<li>Em todos os casos existe uma solu&#xE7;&#xE3;o usando <code>glue</code>.</li>
</ul>
<p>Atualmente sempre que tenho um problema desse tipo uso o <code>glue</code>. At&#xE9; o momento, n&#xE3;o encontrei nenhum problema ou dificuldade. A vida do cientista de dados &#xE9; mais feliz no <code>tidyverse</code>!</p>
<p>&#xC9; isso. Happy coding ;)</p>
</div> </div></div>
