+++
title = "As barras do progresso"
date = "2017-04-10 11:07:31"
categories = ["curso-r"]
+++

<div><p class="text-muted text-uppercase mb-small text-right"> Por <a href="http://curso-r.com/author/julio">Julio</a> 10/04/2017 </p><div id="post-content"> <p>Na jornada da ci&#xEA;ncia de dados, muitas vezes precisamos rodar um mesmo algoritmo em v&#xE1;rios objetos distintos. Quando o algoritmo &#xE9; pesado ou a lista de objetos &#xE9; longa, &#xE9; importante saber em que passo estamos e quanto vai demorar para terminar.</p>
<p>Uma forma de resolver esse problema &#xE9; usando o pacote <code>progress</code>. O objeto <code>progress_bar</code> desse pacote &#xE9; do tipo <a href="https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html"><code>R6</code></a> e tem um m&#xE9;todo <code>new()</code> para criar objetos do tipo &#x201C;barra&#x201D;. Uma barra criada tamb&#xE9;m &#xE9; do tipo <code>R6</code> e possui o m&#xE9;todo <code>tick()</code> para imprimir uma barra de progresso no console.</p>
<p>No exemplo abaixo, nosso interesse &#xE9; aplicar a fun&#xE7;&#xE3;o <code>funcao_demorada</code> nos n&#xFA;meros <code>1:5</code> (um de cada vez, sem usar vetoriza&#xE7;&#xE3;o) e guard&#xE1;-los numa lista.</p>
<pre class="r"><code>funcao_demorada &lt;- function(x) { Sys.sleep(0.5) x ^ 2
}
nums &lt;- 1:5</code></pre>
<p>Podemos fazer isso usando o pacote <code>progress</code>:</p>
<pre class="r"><code>barra &lt;- progress::progress_bar$new(total = length(nums)) # cria a barra resultados &lt;- list()
for (x in nums) { barra$tick() # d&#xE1; um passo resultados[[x]] &lt;- funcao_demorada(x)
}</code></pre>
<p>Como resultados, temos:</p>
<pre class="r"><code>resultados
## [[1]]
## [1] 1
## ## [[2]]
## [1] 4
## ## [[3]]
## [1] 9
## ## [[4]]
## [1] 16
## ## [[5]]
## [1] 25</code></pre>
<p>No entanto, sabemos que os la&#xE7;os <code>for</code> e <code>while</code> do <code>R</code> <a href="http://stackoverflow.com/questions/7142767/why-are-loops-slow-in-r">s&#xE3;o problem&#xE1;ticos</a>. A melhor e mais estilosa forma de fazer esse tipo de opera&#xE7;&#xE3;o no <code>R</code> &#xE9; usando <em>funcionais</em>.</p>
<p>Funcionais s&#xE3;o fun&#xE7;&#xF5;es de fun&#xE7;&#xF5;es. Usamos esses caras sempre que queremos aplicar uma fun&#xE7;&#xE3;o a diversos objetos. Eles s&#xE3;o alternativas mais concisas, elegantes e muitas vezes mais eficientes do que os conhecidos <code>for</code> e <code>while</code>.</p>
<p>Exemplos de funcionais s&#xE3;o os objetos da fam&#xED;lia <code>**ply</code> (<code>lapply</code>, <code>apply</code>, <code>sapply</code> etc.) Os funcionais do R b&#xE1;sico foram generalizados no pacote <code>plyr</code>, que apresenta uma sintaxe organizada e intuitiva.</p>
<p>Uma vantagem do <code>plyr</code> &#xE9; a possibilidade de adicionar barras de progresso como um par&#xE2;metro dos funcionais.</p>
<pre class="r"><code>resultados &lt;- plyr::llply(nums, funcao_demorada, .progress = &apos;text&apos;)
## | | | 0% | |============= | 20% | |========================== | 40% | |======================================= | 60% | |==================================================== | 80% | |=================================================================| 100%</code></pre>
<p>Os resultados s&#xE3;o id&#xEA;nticos e foram omitidos. Bem mais simples, n&#xE3;o?</p>
<div id="usando-purrmap-no-lugar-de-plyrllply" class="section level2"> <p>Recentemente, boa parte das fun&#xE7;&#xF5;es do <code>plyr</code> foram substitu&#xED;das por alternativas nos pacotes <code>dplyr</code> (opera&#xE7;&#xF5;es envolvendo <code>data.frame</code>s) e <code>purrr</code> (opera&#xE7;&#xF5;es envolvendo vetores e listas). Esses pacotes apresentam uma sintaxe mais pr&#xF3;xima da <a href="http://curso-r.com/blog/2017/02/15/2017-02-16-manifesto-tidy/">filosofia <code>tidy</code></a> e portanto faz sentido estud&#xE1;-los!</p>
<p>Infelizmente, as fun&#xE7;&#xF5;es do <code>purrr</code> ainda<a href="http://curso-r.com/blog/2017/04/10/2017-04-08-progress/#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> n&#xE3;o t&#xEA;m um par&#xE2;metro para barras de progresso. Enquanto isso, podemos utilizar o <code>progress::progress_bar</code> mesmo.</p>
<pre class="r"><code>barra &lt;- progress::progress_bar$new(total = length(nums))
resultados &lt;- purrr::map(nums, ~{ barra$tick() funcao_demorada(.x)
})</code></pre>
<p>O c&#xF3;digo fica parecido com solu&#xE7;&#xE3;o usando <code>for()</code>, mas pelo menos estamos usando os pacotes mais recentes ;)</p>
</div>
<div id="eficiencia" class="section level2"> <p>As solu&#xE7;&#xF5;es que mostrei acima apresentam diferen&#xE7;as importantes de efici&#xEA;ncia. Abaixo, encapsulei os c&#xF3;digos em fun&#xE7;&#xF5;es e mudei levemente a opera&#xE7;&#xE3;o que queremos fazer:</p>
<pre class="r"><code>nums &lt;- 1:100
funcao_rapida &lt;- function(x) { x ^ 2
}</code></pre>
<p><code>for()</code>, com e sem progresso:</p>
<pre class="r"><code>for_com &lt;- function(nums) { barra &lt;- progress::progress_bar$new(total = length(nums)) resultados &lt;- list() for(x in nums) { barra$tick() resultados[[x]] &lt;- funcao_rapida(x) } resultados
}
for_sem &lt;- function(nums) { resultados &lt;- list() for(x in nums) resultados[[x]] &lt;- funcao_rapida(x) resultados
}</code></pre>
<p><code>plyr::llply()</code>, com e sem progresso:</p>
<pre class="r"><code>plyr_com &lt;- function(nums) { plyr::llply(nums, funcao_rapida, .progress = &apos;text&apos;)
}
plyr_sem &lt;- function(nums) { plyr::llply(nums, funcao_rapida)
}</code></pre>
<p><code>purrr::map()</code>, com e sem progresso:</p>
<pre class="r"><code>purrr_com &lt;- function(nums) { barra &lt;- progress::progress_bar$new(total = length(nums)) purrr::map(nums, ~{ barra$tick() funcao_rapida(.x) })
}
purrr_sem &lt;- function(nums) { purrr::map(nums, funcao_rapida)
}</code></pre>
<p>Para testar a efici&#xEA;ncia dos algoritmos, utilizamos a fun&#xE7;&#xE3;o <code>microbenchmark::microbenchmark()</code>. Essa fun&#xE7;&#xE3;o calcula o tempo de execu&#xE7;&#xE3;o do algoritmo cem vezes e obt&#xE9;m algumas estat&#xED;sticas b&#xE1;sicas dos tempos obtidos.</p>
<pre class="r"><code>benchmark &lt;- microbenchmark::microbenchmark( for_com(nums), for_sem(nums), plyr_com(nums), plyr_sem(nums), purrr_com(nums), purrr_sem(nums)
)</code></pre>
<p>Os resultados da Tabela <a href="http://curso-r.com/blog/2017/04/10/2017-04-08-progress/#tab:eficiencia">1</a> s&#xE3;o surpreendentes. Primeiro, as fun&#xE7;&#xF5;es que n&#xE3;o usam barras de progresso s&#xE3;o muito mais r&#xE1;pidas, chegando a quase 10 vezes em alguns casos. A fun&#xE7;&#xE3;o do <code>plyr</code> &#xE9; mais lenta que o <code>for()</code> quando usamos barras de progresso, mas &#xE9; mais r&#xE1;pida quando n&#xE3;o usamos. O <code>purrr</code> &#xE9; o mais r&#xE1;pido nos dois casos.</p>
<table>
<caption><span id="tab:eficiencia">Table 1: </span>Resultados do benchmark. Os tempos est&#xE3;o em milisegundos.</caption>
<thead> </thead>
<tbody>
<tr class="odd">
<td>for_com(nums)</td>
<td>8.666</td>
<td>10.367</td>
<td>9.952</td>
<td>17.155</td>
</tr>
<tr class="even">
<td>for_sem(nums)</td>
<td>0.161</td>
<td>0.219</td>
<td>0.196</td>
<td>2.211</td>
</tr>
<tr class="odd">
<td>plyr_com(nums)</td>
<td>9.193</td>
<td>10.754</td>
<td>10.511</td>
<td>18.386</td>
</tr>
<tr class="even">
<td>plyr_sem(nums)</td>
<td>0.116</td>
<td>0.155</td>
<td>0.156</td>
<td>0.271</td>
</tr>
<tr class="odd">
<td>purrr_com(nums)</td>
<td>8.776</td>
<td>10.376</td>
<td>9.982</td>
<td>14.424</td>
</tr>
<tr class="even">
<td>purrr_sem(nums)</td>
<td>0.092</td>
<td>0.131</td>
<td>0.124</td>
<td>0.538</td>
</tr>
</tbody>
</table>
<p>Mas n&#xE3;o leve esses resultados t&#xE3;o a s&#xE9;rio. Na pr&#xE1;tica, a parte mais demorada fica na fun&#xE7;&#xE3;o aplicada e n&#xE3;o no funcional utilizado, implicando que essas diferen&#xE7;as sejam ignor&#xE1;veis. S&#xF3; recomendo mesmo abandonar o <code>for()</code> para opera&#xE7;&#xF5;es desse tipo, pois o tempo de execu&#xE7;&#xE3;o n&#xE3;o cresce <strong>linearmente</strong> com o tamanho dos objetos, como &#xE9; poss&#xED;vel ver na Figura <a href="http://curso-r.com/blog/2017/04/10/2017-04-08-progress/#fig:for">1</a>.</p>
<div class="figure"><span id="fig:for"></span>
<img src="http://curso-r.com/blog/2017-04-08-progress_files/figure-html/for-1.png" alt="Tempo do for em fun&#xE7;&#xE3;o do n&#xFA;mero de inputs" width="768">
<p class="caption">
Figure 1: Tempo do for em fun&#xE7;&#xE3;o do n&#xFA;mero de inputs
</p>
</div>
</div>
<h2>Resumo</h2>
<ul>
<li>Use o objeto <code>progress::progress_bar</code> sempre que quiser fazer barras de progresso.</li>
<li>Use o m&#xE9;todo <code>$new(total = n)</code> para criar uma barra.</li>
<li>Use o m&#xE9;todo <code>$tick()</code> dentro do loop para mostrar que andou um passo do algoritmo.</li>
<li>Tome cuidado com a efici&#xEA;ncia do algoritmo quando usa barras de progresso.</li>
</ul> <h2>Outros links</h2>
<ul>
<li>Veja <code>?dplyr::progress_estimated</code>.</li>
<li><a href="https://github.com/gaborcsardi/progress">Pacote <code>progress</code></a>.</li>
<li><a href="http://adv-r.had.co.nz/Functional-programming.html">Programa&#xE7;&#xE3;o funcional</a>.</li>
</ul> </div></div>
